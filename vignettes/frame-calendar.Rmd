---
title: "Calendar-based graphics"
author: "Earo Wang, Di Cook, Rob J Hyndman"
date: "`r Sys.Date()`"
bibliography: references.bib
biblio-style: authoryear-comp
link-citations: yes
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{frame-calendar}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

```{r initial, echo = FALSE, cache = FALSE, results = 'hide'}
library(knitr)
opts_chunk$set(
  warning = FALSE, message = FALSE, echo = TRUE,
  fig.width = 7, fig.height = 6, fig.align = 'centre'
)
```

Calendar-based graphics turn out a useful tool for visually unfolding people's daily schedules in details, such as hourly foot traffic in CBD, daily residential electricity demand and etc. It arranges the values according to the corresponding dates into a calendar layout, which is comprised of weekdays on columns and weeks of a month on rows for a common monthly calendar. The idea originates from @van_wijk_cluster_1999 and is implemented into a couple of R packages ([ggTimeSeries](https://github.com/AtherEnergy/ggTimeSeries) and [ggcal](https://github.com/jayjacobs/ggcal)), yet they all are a variant of heatmap in temporal context. We extend the calendar-based graphics to a broader range of applications using linear algebra tools. For example, (1) it not only handles with data of daily intervals but also of higher frequency like hourly data; (2) it is no longer constrained to heatmap but can be used with other types of *Geoms*; (3) the built-in calendars include *monthly*, *weekly*, and *daily* types for the purpose of comparisons between different temporal components. The function `frame_calendar()` returns the computed calendar grids as a data frame or a tibble according to its data input, and *ggplot2* takes care of the plotting as you usually do with a data frame.

We are going to use Melbourne pedestrian data (shipped with the package) as an example throughout the vignette, which is sourced from [Melbourne Open Data Portal](http://www.pedestrian.melbourne.vic.gov.au). The subset of the data contains 7 sensors counting foot traffic at hourly intervals across the city of Melbourne from January to April in 2017.

```{r load}
library(tidyr)
library(dplyr)
library(viridis)
library(sugrrants)
pedestrian17 <- filter(pedestrian, Year == "2017")
head(pedestrian17)
```

We'll start with one sensor only--Melbourne Convention Exhibition Centre--to explain the basic use of the `frame_calendar()`. As it attempts to fit into the *tidyverse* framework, the interface should be straightforward to those who use *tidyverse* on a daily basis. The first argument is the `data` so that the data frame can directly be piped into the function using `%>%`. A variable indicating time of day could be mapped to `x`, a value variable of interest mapped to `y`. `date` requires a `Date` variable to organise the data into a correct chronological order . See `?frame_calendar()` for more options. In this case, *Time* as hour of day is used for `x` and *Hourly_Counts* as value for `y`. It returns a data frame including newly added columns *.Time* and *.Hourly_Counts* with a prefix "." of the variable names. These new columns contain the rearranged coordinates for the calendar plots later.

```{r centre}
centre <- pedestrian17 %>% 
  filter(Sensor_Name == "Melbourne Convention Exhibition Centre")
centre_calendar <- centre %>%
  frame_calendar(x = Time, y = Hourly_Counts, date = Date, calendar = "monthly")
head(centre_calendar)
```

Consequently, *.Time* and *.Hourly_Counts* are mapped to the x and y axes respectively grouped by *Date* when using `geom_line()`. The transformed *.Time* and *.Hourly_Counts* variables no longer carry their initial meanings, and thereby their values are meaningless.

```{r centre-plot}
p1 <- centre_calendar %>% 
  ggplot(aes(x = .Time, y = .Hourly_Counts, group = Date)) +
  geom_line()
p1
```

To make the plot more accessible and informative, we provide another function `prettify()` to go hand in hand with `frame_calendar()`. It takes a `ggplot` object and gives sensible breaks and labels. It can be noted that the calendar-based graphic depicts time of day, day of week, and other calendar effects like public holiday in a clear manner. (NOTE: `prettify()` works better with line and point geoms at this stage.)

```{r centre-more}
prettify(p1)
```

## Scales

Scaling is controlled by the `scale` argument: `NULL` is the default suggesting to be scaled globally. The figure above shows the global scale that enables overall comparison. Another option `free` means to be scaled for each daily block individually. It puts more emphasis on a single day shape instead of magnitude comparison.

```{r centre-free, fig.height = 2.5}
centre_calendar_free <- centre %>%
  frame_calendar(x = Time, y = Hourly_Counts, date = Date, calendar = "monthly",
    scale = "free", ncol = 4)
p2 <- ggplot(centre_calendar_free, 
        aes(x = .Time, y = .Hourly_Counts, group = Date)) +
  geom_line()
prettify(p2, label = NULL)
```

The other two choices are `free_wday` and `free_mday`, scaled conditionally on each weekday and each day of month respectively. The code snippet below gives the scaling by weekdays so that it enables to compare the magnitudes across Mondays, Tuesdays, and so on.

```{r centre-wday, fig.height = 2.5}
centre_calendar_wday <- centre %>%
  frame_calendar(x = Time, y = Hourly_Counts, date = Date, calendar = "monthly",
    scale = "free_wday", ncol = 4)
p3 <- ggplot(centre_calendar_wday, 
        aes(x = .Time, y = .Hourly_Counts, group = Date)) +
  geom_line()
prettify(p3, label = NULL)
```

## Use in conjunction with `group_by`

We can also superimpose one sensor on top of the other. Without using `group_by()`, they will share the common scale on the overlaying graph.

```{r overlay, fig.height = 4}
two_sensors <- pedestrian17 %>%
  filter(Sensor_Name %in% c("Melbourne Convention Exhibition Centre", "Lonsdale St (South)"))
two_sensors_calendar <- two_sensors %>%
  frame_calendar(x = Time, y = Hourly_Counts, date = Date, ncol = 4)
p4 <- two_sensors_calendar %>%
  ggplot(aes(x = .Time, y = .Hourly_Counts, group = Date, colour = Sensor_Name)) +
  geom_line(alpha = 0.7) +
  scale_colour_brewer(palette = "Dark2") +
  theme(legend.position = "bottom")
prettify(p4, label = NULL)
```

The `frame_calendar()` function can be naturally combined with `group_by()`, and hence the grouped variable has its own scale.

```{r ped-facet}
grped_calendar <- two_sensors %>% 
  group_by(Sensor_Name) %>%
  frame_calendar(x = Time, y = Hourly_Counts, date = Date, ncol = 4)
grped_calendar %>%
  ggplot(aes(x = .Time, y = .Hourly_Counts, group = Date)) +
  geom_line() +
  facet_grid(Sensor_Name ~ .)
```

## More geoms

It's not necessarily working with lines but other geoms too. One example is a lag scatterplot on a "daily" calendar. Lagged hourly counts are plotted against hourly counts in each daily cell using a point geom.

```{r ped-lag, fig.height = 2, fig.width = 8, warning = TRUE}
centre_lagged <- centre %>%
  mutate(Lagged_Counts = dplyr::lag(Hourly_Counts))
centre_lagged_calendar <- centre_lagged %>% 
  frame_calendar(x = Hourly_Counts, y = Lagged_Counts, date = Date,
    calendar = "daily")
p3 <- centre_lagged_calendar %>%
  ggplot(aes(x = .Hourly_Counts, y = .Lagged_Counts, group = Date)) +
  geom_point(size = 0.5)
prettify(p3, size = 3)
```

Furthermore, the argument `y` is possible to take multiple variable names in a way combined with `vars()`. It's difficult to spot the differences between two sensors from the overlaying plot shown earlier. The rectangular glyphs arranged on a "weekly" calendar are plotted to illustrate the multiple `y`s use and the differences between sensors. The long data format is firstly converted to the wide format using `tidyr::spread()` [@wickham2014tidy]. These two sensors are variables rather than values now, and hence can be passed to `y`. 

```{r ped-daily}
two_sensors_wide <- two_sensors %>% 
  select(-Sensor_ID) %>% 
  spread(key = Sensor_Name, value = Hourly_Counts) %>% 
  rename(
    Centre = `Melbourne Convention Exhibition Centre`,
    Lonsdale = `Lonsdale St (South)`
  ) %>%
  mutate(
    Diff = Centre - Lonsdale,
    More = if_else(Diff > 0, "Centre", "Lonsdale")
  )
sensors_wide_calendar <- two_sensors_wide %>% 
  frame_calendar(x = Time, y = vars(Centre, Lonsdale), date = Date, 
    calendar = "weekly" )
head(sensors_wide_calendar)
```

Having multiple `y`s makes it a little easier when mapping to some geoms that contain the `ymin` and `ymax` arguments, such as `geom_rect` and `geom_ribbon`. Interestingly, Lonsdale Street is busier than Convention Centre in the evening, vice versa in the day time.

```{r ped-daily-plot}
p5 <- sensors_wide_calendar %>%
  ggplot() +
  geom_rect(aes(xmin = .Time, xmax = .Time + 0.005,
    ymin = .Lonsdale, ymax = .Centre, fill = More
  )) +
  scale_fill_brewer(palette = "Dark2") +
  theme(legend.position = "bottom")
prettify(p5)
``` 

Can we plot a heatmap using `frame_calendar()` too? Yep, either `x` or `y` can be given as 1 implying identity across days. If both `x` and `y` are given as 1, only calendar grids are returned. A heatmap therefore can be drawn.

```{r ped-max}
centre_daily <- centre %>%
  group_by(Date) %>%
  summarise(Max_Counts = max(Hourly_Counts)) %>%
  ungroup()
centre_max_calendar <- centre_daily %>%
  frame_calendar(x = 1, y = 1, date = Date, calendar = "monthly")
head(centre_max_calendar)
centre_max_calendar %>%
  ggplot(aes(x = .x, y = .y)) +
  geom_tile(aes(fill = Max_Counts), colour = "grey50") +
  scale_fill_viridis()
```

## Summary

As its name suggests, `frame_calendar()` just gives a rearranged data frame to you and leaves the plotting to *ggplot2*. This lends itself to more flexibility of calendar-based visualisation. In addition, some of these plots shown above may be produced using facets on temporal units by *ggplot2*; however, `frame_calendar()` coupled with *ggplot2* is much faster than `facet_*` as it's lighter-weight. Lastly, it can handle with long historical temporal data easily on a limited screen space as a result of calendar-based glyphs.

## Reference
