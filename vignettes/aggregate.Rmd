---
title: "Aggregate temporal data over fixed calendar periods"
author: "Earo Wang"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

In base R, the `ts` function provides an easy way to create a time series object
consisting of input values and user-specified time attributes of
starting/ending time points and frequency. Its extension to manage multivariate
time series is `mts`. There are many built-in functions and R packages for
analysing and forecasting time series data based on the `ts` and `mts` objects.
For example, `aggregate.ts` applies a function to each time block and the
widely-used `forecast` package helps with time series forecast. The simplicity
achieves at the expense of some flexibilities. The attribute `frequency` implies
input data over regular time intervals, which makes no room for irregular time
series. The `mts` class does not cater for longitudinal data recording the same
subjects at different points in time, as longitudinal data usually comes in long
form whereas `mts` calls for a wide data format. Although R represents calendar
date-times in `POSIXlt`, `POSIXct` and `Date` classes, `ts` and `mts` do not
generate such date-time classes. The packages, `zoo` and `xts`, fill the gap here.

However, time series analysis starts off as a general data frame with at least
one date-time variable. It is necessary to convert `data.frame` to `ts`, `zoo`
or `xts` classes in order to analyse and model temporal data. In doing so, the
external information attached to a time series is lost, since a wide data format
is employed by these objects. Wickham's `tidyverse` package lubricates the work 
flow for data analysis. Compared to `data.frame`, temporal data is a special
case with the ordering of time. To leverage the power of `tidyverse` and reduce the 
hassles of classes conversion, more functionality are brought into time series
data while staying in the `tidyverse` expertise.

```{r load_ped, message = FALSE, warning = FALSE}
library(dplyr)
library(ggplot2)
library(sugrrants)
data(pedestrian)
pedestrian
```

## Extract the upper-level of date-times

One of the data sets shipped with the package is counting pedestrian passing by 
at 8 sensors in the downtown of Melbourne every hour over the course of 2015.

```{r town_hall1, message = FALSE, warning = FALSE}
town_hall <- pedestrian %>%
  filter(Sensor_ID == 4)
town_hall %>%
  mutate(Week = as_week(Date_Time)) %>%
  group_by(Week) %>%
  summarise(Max_Counts = max(Hourly_Counts, na.rm = TRUE))
```

## Apply a function to fixed calendar periods

```{r town_hall2, message = FALSE, warning = FALSE}
town_hall %>%
  by_week(.index = Date_Time, .value = Hourly_Counts, 
    .f = max, na.rm = TRUE, .label = "Max_Counts")
```

The data set used in the vignette is daily temperatures at 17 weather stations
across Sweden. It describes the observed temperature on a daily basis over 10
years between 1998 and 2008 along with 17 weather stations of longitudes and
latitudes. 

```{r load_temp, message = FALSE, warning = FALSE}
data(sweden_temp)
sweden_temp
```

Time series data structure in conjunction with data frame.

```{r m3}
m3 <- function(x, na.rm = TRUE) {
  average <- mean(x, na.rm = na.rm)
  minimum <- min(x, na.rm = na.rm)
  maximum <- max(x, na.rm = na.rm)
  return(c(minimum, average, maximum))
}
```

```{r aggregate}
sweden_temp_month <- sweden_temp %>% 
  group_by(locations) %>% 
  by_month(date, temp, .f = m3, na.rm = TRUE, .label = "Stats")
```

## ToDo

* All the aggregate functions `by_month`, `by_week` and `by_day`:
    + If the argument `.index` is not supplied, it should look for a variable of
    date-times in the `.data`.
    + The argument `.value` now only takes one variable, but should
    aggregate over a few variables.
    + Probably unnecessary to have `.value` argument. Could think about
      something `.f = FUN(.value)`.
    + An additional argument `n` is needed to indicate the number of fixed
    calendar periods to be aggregated. The default is `n = 1`.
